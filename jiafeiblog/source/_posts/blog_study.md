---
title: 优质博客文章列表
date: 2024-06-12 12:12:31
categories:
- 学习记录
tags:
- 学习
- 博客
---

规则说明：
- 标题规则：## 【啥分类】博客文章标题
- 子内容：
  - 内容总结：说明学到了什么知识
  - 对自己的影响：知识体系、未来规划、等

## 【分类】标题模版
### 内容总结：xxx
### 对自己的影响：xxx


## 【学习成长求职】课程
### 内容总结：技术人求职指南-笔记
### 对自己的影响：
- 深入了解了求职中的核心内容：
  - 简历梳理：自我介绍、项目介绍
  - 自我认知梳理
  - 技术面试表达和沟通
  - hr面试表达和沟通
- 职业发展规划
  - 持续的精进，保证自己有强有力的竞争力
## 【Android 单线程UI机制】Android组件系列：Handler机制详解 
### 内容总结：Handler-Message-Looper源码学习
### 对自己的影响：
- 复习了Android 单线程UI的底层实现
- 了解了一个UI模型：主线程UI模型
  - 一个UI主线程，多个子线程（io线程、计算线程等）的交互模式
## 【网络技术】WebSocket：5分钟从入门到精通 2024-05-02
### 内容总结：WebSocket协议
- 主要协议报文格式、原理和流程、特点、使用场景
### 对自己的影响：
- 上学那会对WebSocket就一知半解，老是说这个很牛逼，可是自己却不知道牛逼在哪里。。
- 学习下来，确实对于互联网来说是非常有用的一个协议，可以用来做很多事情：
  - 聊天室
  - 多人在线文档编辑，例如飞书文档：
[图片]
  
## 【音视频学习】2024-05-04
音视频教学:(一) 音视频基础知识
https://www.bilibili.com/video/BV1t4411p7Ph/?spm_id_from=333.337.search-card.all.click&vd_source=43018fda009d03e875bba9987f36baf4
玩转Android音视频开发：34节精讲从0到1打造剪映APP，底层原理→实战进阶全盘拿下！
https://www.bilibili.com/video/BV1xL4y187ma/?spm_id_from=333.337.search-card.all.click&vd_source=43018fda009d03e875bba9987f36baf4
系统学习，需要规划学习路线，逐步学习和实践
### 内容总结：基于26X的编码算法到音视频应用层的技术体系
### 对自己的影响：
- 大学的时候学过opencv的一些使用和处理，但是浅尝辄止，没有深入学习和开发
- 了解到视频编码的原理，也挺感兴趣的
- 系统学习：需要规划学习路线，逐步学习和实践
## 【业务容器化】选型分析：深入分析App主流各大跨平台框架
https://mp.weixin.qq.com/s/I2BMm3m9Ffzu8qz6PYmTUA
### 内容总结：总结市面上开源的App跨平台框架
### 对自己的影响：
- 了解常见框架的优劣，有的渲染好，有的数据通信好，有的都好
- 新起之秀：uni-appx，js转多原生能力建设，开发与部署分离
## 【前端】苦尽甘来，下一站，上岸
https://juejin.cn/post/7363556508604219404#heading-0
### 内容总结：面经总结，扩展了很多知识
- 知识点总结：
  - vue相关：脚手架、生命周期、安全、响应式编程
  - 跨域：https://juejin.cn/post/6844903758409760775?searchId=20240503215754E3920962C487F8780C56
  - Vite https://juejin.cn/post/7280747221510144054
  - JWT（Json Web Token） https://juejin.cn/post/7232550589964140602?searchId=20240503221006D24BD5B7368ABF6F88F5
  - 50个Vue知识点 https://juejin.cn/post/6984210440276410399#heading-32
- 经验总结——All In
### 对自己的影响：千万别想太多，准备 & 面试 & 复盘学习 & 面试 -> 不断迭代就行了
- 求职是一个持久战，需要持之以恒的去投简历吗&面试，做面试复盘，对知识点查漏补缺和强化处理
- 对于不懂得知识：学习 & 研究，享受其中
- 学习了很多前端知识
## 【网络技术】Linux 网络编程：TCP、UDP
https://juejin.cn/post/7357172505960169487
### 内容总结：
- TCP、UDP的基础原理
- 客户端长连接应用以及问题处理
### 对自己的影响：
- 复习了网络相关知识，实践了相关内容
- 至理名言：实践出真知
## 【网络技术】Java BIO NIO
https://juejin.cn/post/7120529881229852685
### 内容总结：内容不够细致，需要进一步学习
- Java BIO NIO技术学习
- Reactor模型学习，这个模型可以基于不同语言进行实现
- Linux 网络IO模型：
  - 阻塞式IO：内核阻塞，Java中是
  - 非阻塞式IO：轮询等待
  - IO多路复用：文件读写阻塞
  - 信号驱动式IO：SIGIO信号阻塞
  - 异步IO模型：异步通知阻塞
- Linux IO多路复用
  - 文件描述符 
  - Select
    elect函数可以监视3类文件描述符：writeFds、readFds、execptFds。调用select函数后进程会阻塞，直到有就绪的文件描述符。当select又返回时，就会唤醒进程来处理io事件，而且是会遍历整个描述符数组来处理就绪的io事件。 select的优点是跨平台支持，缺点是单个进程的文件描述符是有OS控制的，Linux最大是1024个，但是可以修改。另一个缺点就是需要遍历整个文件描述符数组。
  - Poll
    - 和select十分相似，只不过poll对文件描述符的管理时基于链表，而且poll没有限制描述符数量，当连接量较大时性能会急剧下降。和select一样，调用poll函数后，一旦有就绪事件需要轮询整个链表。
  - epoll
    - epoll是在Linux2.6版本推出的一种IO多路实现手段。相对于poll和select，epoll做了很大优化和改进。
    - epoll的优化思路有2点：
      1. 功能分离：创建epoll、socket监视注册、等待数据分为3个API实现。             
      2.  就绪列表：select和poll低效的根本原因是要遍历所有的socket，epoll则维护了一个就绪列表，引用了收到了数据的socket，这样就避免了全链表扫描。
    - 当socket收到数据后，中断程序会操作eventpoll，将对应的socket挂载到就绪列表里面，后续恢复进程来处理，此时只需要处理就绪列表里面的socket。 当进程调用epoll_creat函数时，Linux内核会创建一个Eventpoll结构体，然后在内核缓冲区中创建一个红黑树来存储后续连接注册的socket，然后也会在Eventpoll中创建一个就绪链表。后续只需要监听这个链表有没有就绪的socket即可。 
    - epoll相对于select和poll有了很大的优势，保持数万数十万连接也不是问题。但是在极端情况下，例如就序列表的元素十分多时，也会有瓶颈。
### 对自己的影响：
- 复习了Java BIO、NIO
- 对Android底层（Linux）机制有了深入的了解。
  - epoll机制的应用：Android native handler机制，实现不占用cpu的等待机制
## 【Android 系统安全】当 App 有了系统权限，真的可以为所欲为？
https://zhuanlan.zhihu.com/p/612472982
https://github.com/davinci1010/pinduoduo_backdoor
### 内容总结：梳理了PDD app的黑科技，Linux系统权限很重要
### 对自己的影响：了解到突破系统权限，可以做的事情非常多，但是要在合法的范围内。
## 【Vue.js前端】「自我检验」熬夜总结50个Vue知识点，全都会你就是神！！！
### 内容总结：常见的Vue.js相关的面试题
vue.js 虚拟DOM的底层原理
Vue.js 是一个用于构建用户界面的渐进式JavaScript框架。它的核心特性之一是虚拟DOM（Virtual DOM），这是一种编程概念，用于提高Web应用程序的渲染效率。
虚拟DOM的基本原理
- 什么是虚拟DOM：
  - 虚拟DOM是一个编程概念，它指的是在内存中（而非真实DOM树）表示的DOM树的结构（虚拟DOM是真实DOM在内存的中镜像，他们的状态是一致的，通过同步机制进行同步）。它允许Web应用在不直接操作浏览器DOM的情况下进行高效的更新。
- 为什么使用虚拟DOM：
  - 性能：直接操作真实DOM是昂贵的，因为它会触发浏览器的重排（reflow）和重绘（repaint）过程。虚拟DOM允许应用在内存中计算出最小的更新操作（始终最高效更新，避免多余的重排和重绘），然后一次性应用到真实DOM上。
  - 跨平台：虚拟DOM允许Vue应用在不同平台（如Web、Weex或可能的未来的平台）上运行，而不需要针对每个平台编写特定的渲染逻辑。
- 虚拟DOM的工作流程：
  - 渲染阶段：Vue应用的模板被编译成虚拟DOM树。
  - 响应式更新：当数据变化时，Vue的响应式系统会触发相应的更新。
  - Diffing（差异比较）：Vue使用高效的算法比较新旧虚拟DOM树，找出最小的更新操作。
  - 打补丁：根据Diffing的结果，Vue生成一个补丁列表，然后应用到真实DOM上。

虚拟DOM的实现细节
- 对象表示：在Vue中，虚拟DOM是通过一个JavaScript对象来表示的。这个对象包含了真实DOM节点的所有信息，如标签名、子节点、属性等。
- 组件化：虚拟DOM树可以包含组件，每个组件也是一个虚拟DOM节点，它有自己的模板和逻辑。
- Key属性：在列表渲染时，Vue使用key属性来跟踪每个节点的身份，以提高更新列表的效率。
- Diffing算法：
  - 同层比较：新旧虚拟DOM树在同层进行比较，如果节点类型不同，则直接替换。
  - 树间比较：如果节点类型相同，则比较它们的属性，如果属性发生变化，则更新。
  - 子节点比较：对于子节点，Vue使用一个高效的算法来比较并更新它们，而不是简单地替换整个子树。
- 批量更新：
  - Vue将所有的数据变化收集到一个队列中，然后批量处理，这样可以减少不必要的DOM操作。
- 异步更新：
  - Vue在检测到数据变化时并不会立即更新DOM，而是将更新推迟到下一个事件循环（单线程UI更新机制）中，这样可以通过合并多个数据变化来优化性能。
总结
虚拟DOM是Vue.js中的一个关键特性，它通过在内存中模拟DOM的结构和操作，使得Web应用能够以更高的效率进行更新。通过Diffing算法和批量异步更新，Vue能够最小化真实DOM的操作，从而提高性能。同时，虚拟DOM也为Vue应用的跨平台渲染提供了可能。
浏览器DOM重排和重绘的机制，及其常见的触发场景
找到了第 1 篇资料：浏览器渲染机制：重排（Reflow）与重绘（Repaint）以及 ...
找到了第 2 篇资料：浏览器的渲染机制（dom的重绘和回流） - 知乎
找到了第 3 篇资料：web性能-优化dom操作（重排 重绘） - 掘金
找到了第 4 篇资料：渲染页面：浏览器的工作原理 - Web 性能 | MDN
找到了第 5 篇资料：『JavaScript』DOM回流与重绘深度剖析：提升Web应用 ...
找到了第 6 篇资料：深入理解浏览器的重绘与重排 - 知乎
找到了第 7 篇资料：39：浏览器底层渲染机制3：DOM回流和重绘-CSDN博客
找到了第 8 篇资料：深入理解浏览器的重绘与重排 - 知乎
找到了第 9 篇资料：浏览器渲染机制、重排、重绘 - CSDN博客
找到了第 10 篇资料：浏览器渲染机制、重绘、重排 - CSDN博客
找到了第 11 篇资料：搞懂浏览器渲染原理（重排与重绘） | JackySummer
浏览器的DOM重排（Reflow）和重绘（Repaint）是渲染页面的关键步骤，它们对性能有显著影响。

DOM重排（Reflow）
重排是指浏览器重新计算DOM元素的几何属性（位置和尺寸），并更新渲染树的过程。这通常发生在以下几种情况下：
- DOM结构变化：如添加或删除可见DOM元素。
- 样式属性变更：影响元素几何属性的CSS属性变化，例如宽度、高度、外边距、内边距、边框等。
- 获取布局信息：JavaScript请求读取依赖于布局信息的样式属性，如offsetTop、offsetLeft等。
- 窗口或设备视口尺寸变化：如浏览器窗口大小调整。

DOM重绘（Repaint）
重绘是指浏览器重新绘制元素的视觉表现，但不影响其在文档布局中的位置和尺寸。这通常发生在：
- 视觉样式改变：如颜色、背景色、边框颜色、阴影、不透明度等改变。
- 伪类或伪元素激活：如:hover、:focus等伪类被触发。
- 元素透明度变化：opacity属性改变可能影响其下所有内容的重绘。

性能影响
重排和重绘都会影响页面性能，其中重排由于需要重新计算元素的几何属性，通常比重绘更消耗性能。触发重排的情况几乎都会触发重绘，但重绘不一定会触发重排。

优化策略
为了减少重排和重绘的性能开销，可以采取以下策略：
- 合并DOM操作：一次性完成多个元素的改动，而不是分散进行。
- 离屏DOM操作：使用DocumentFragment或通过设置display: none隐藏元素后再修改，减少直接影响。
- CSS动画：使用CSS的transition或animation来替代JavaScript动画，因为它们通常只触发重绘而不触发重排。
- 预读取布局信息：连续读取布局信息时，先读取后操作，避免反复查询。
- 使用绝对定位：将频繁变动的元素设置为position: absolute或fixed，减少对其他元素的影响。
- 优化CSS选择器：避免复杂选择器，减少样式更改时的重排范围。
- 硬件加速：使用transform或will-change属性提示浏览器进行硬件加速，减少重排。

通过理解浏览器的渲染机制并采取适当的优化措施，可以有效提升页面性能，减少不必要的重排和重绘操作。
vue的虚拟dom机制相比与传统直接操作DOM的场景的性能优化了多少？
Vue.js 的虚拟 DOM 机制相比直接操作 DOM 在性能上带来了显著的提升，但提升的具体数值会根据应用的具体情况而变化。以下是虚拟 DOM 性能优化的几个关键点：
1. 批量更新：Vue 将数据变化收集在队列中，然后在下一个事件循环“tick”中一次性更新 DOM，这避免了逐个立即更新导致的多次重排和重绘。
2. 细粒度的 Diff 算法：Vue 的虚拟 DOM 使用高效的算法来比较新旧虚拟 DOM 树的差异，从而计算出最小的更新操作，这减少了不必要的 DOM 操作。
3. 组件化：Vue 的组件系统使得开发者可以局部更新 DOM，而不是整个页面，这限制了重排和重绘的范围。
4. 异步更新队列：Vue 在同一个事件循环中收集所有的数据变化，然后统一处理，这减少了浏览器的重排和重绘次数。
5. 优化的事件处理：Vue 使用事件委托和防抖/节流技术来减少事件处理的性能开销。
6. SSR 支持：Vue 支持服务器端渲染（SSR），这可以减少首屏加载时间，对性能和SEO优化有显著帮助。
7. Key 绑定：列表渲染时，Vue 使用唯一的 key 来识别每个节点，这使得 Vue 能够更高效地更新虚拟 DOM。
8. 内置指令和组件：Vue 提供了一系列内置的指令和组件，如 v-show、v-if 等，它们在底层进行了优化，以减少不必要的 DOM 操作。
性能提升的量化数值很难一概而论，因为它受到很多因素的影响，包括应用的复杂度、数据变化的频率、用户的设备性能等。在某些情况下，虚拟 DOM 可以减少高达 90% 的不必要的 DOM 操作，但在其他情况下，这个数字可能会低一些。总的来说，虚拟 DOM 为开发者提供了一种更高效、更易于管理的方式来更新用户界面，而无需深入了解底层的 DOM 操作细节。
### 对自己的影响：了解一些常见的面试题，做一定的储备。
## 【Android 内存泄漏】Android Native内存泄漏检测方案详解
https://juejin.cn/post/7366972839780237362
延展阅读：https://juejin.cn/post/6844903891264520200
### 内容总结：介绍了常见的native内存泄漏检测方案
- AddressSanitizer——AScan 
  - 内存局部变换，影子内存、编译器插桩
- LeakSanitizer——LScan
  - 程序退出时，扫描内存空间
- Valgrind
  - 动态二进制仪器（Dynamic Binary Instrumentation，DBI）的技术
    - ## 【运行时代码插入-很慢】在运行时将程序的机器代码翻译成一个中间表示（Intermediate Representation，IR），然后在IR上插入检查代码，最后将IR翻译回机器代码并执行
- 手动检测
  - 重载内存分配和释放函数（类似与AScan）：你可以重载malloc、calloc、realloc和free等内存分配和释放函数，以便在每次分配和释放内存时记录相关信息。
  - 定期检查内存分配表（类似于LScan）：你可以在程序的关键点（如退出时或在特定的间隔）检查内存分配表，找出没有被释放的内存
  - 在应用中添加内存泄漏检测功能（内测包——检测功能）
- 生产开发如何避免native内存泄漏
  - 编码规范
  - 带按摩审查
  - 自动化测试
  - 性能监控
  - 问题定位
### 对自己的影响：
- 多学习一下Android开发者网站的技术工具，
## 【Android 逆向实践】
https://juejin.cn/post/7367186272849608738#heading-4
### 内容总结：常见的反编译工具和代码阅读，以及代码修改操作
### 对自己的影响：学习勿急躁，追求质量，逐步推进，多做实践。
## 【个人成长】程序员如何提升个人技术影响力
https://tech.dewu.com/article?id=111
### 内容总结：
[图片]
写技术文章万能主线逻辑：背景、现状、问题、解决思路、收益、价值 
- 背景：针对受众 ，讲一讲为什么要梳理这个话题，有什么价值和意义
-  现状：现在行业现状、得物现状是什么样的，处于什么阶段 
- 问题：可以理解为本文的观点或者论点，有什么问题 
- 解决思路：针对问题——提出方案——结合实践——方案升级——有可以复用的方法论更好 
- 收益/价值：升华主题 文章不可或缺的部分： 1.一条清晰的逻辑主线：是什么——为什么——怎么做——收益 2.一个亮眼的标题（一句话概括正文，并吸引读者兴趣） 3.整体文章通畅，避免下错别字（需要检查逻辑、错别字、观点等） 4.不要忽略总结
### 对自己的影响

## 【UI架构】Android MVI 架构简介
https://blog.csdn.net/u013762572/article/details/121582509
### 内容总结：Android MVI架构，基于JetPack组件的创新架构范式
Android MVI（Model-View-Intent）架构是一种软件设计模式，特别适用于构建可维护和可扩展的Android应用程序。它是基于响应式编程原则的一种现代架构方法，旨在简化UI管理和状态处理。
MVI的核心理念围绕着单向数据流，确保应用程序状态的一致性和可预测性。
MVI架构的组成部分：
1. Model（模型）：负责处理业务逻辑和数据操作，比如从数据库或网络获取数据。模型接收来自Intent的请求，处理这些请求后，可能更新应用程序的状态。
2. View（视图）：代表用户界面。在MVI中，视图不仅展示数据，还会发送用户的意图（Intent）给模型层。这些意图可以是对用户操作的直接反应，例如点击按钮。
3. Intent（意图）：在MVI架构中，Intent不是Android框架中的Intent类，而是一个更广泛的概念，代表用户想要执行的动作或者视图到模型层的请求。它可以视为用户交互的抽象描述，驱动应用程序状态的改变。
MVI工作流程：
- 用户与视图交互，触发一个Intent。
- Intent被发送到模型层。
- 模型层根据收到的Intent处理业务逻辑，可能包括访问数据库、网络请求等。
- 处理完毕后，模型层会计算出一个新的应用程序状态（State），这个状态是不可变的（Immutable），确保状态的一致性。
- 新状态通过观察者模式（如RxJava、LiveData等）返回给视图层。
- 视图层根据最新的状态自动更新UI，完成界面的刷新。
MVI的优势：
- 简化状态管理：通过集中管理状态，减少因为多线程或复杂交互导致的状态不一致问题。
- 可预测性：单向数据流使得应用的行为更加可预测，便于调试和测试。
- 易于维护和扩展：清晰的分层和分离关注点使得代码更模块化，便于团队协作和项目维护。
- 响应式UI：自动根据状态更新UI，无需手动控制每个UI元素的变化。

MVI架构因其清晰的数据流向和高效的状态管理，在现代Android开发中越来越受欢迎。
### 对自己的影响：
## 【设计模式】软件设计模式，编程原则还有代码片段
https://java-design-patterns.com/zh/
### 内容总结：java实现的设计模式
### 对自己的影响：学习的核心在于复习
## 【面试知识】CS-Notes 面试笔记
### 内容总结：软件开发 面试知识
### 对自己的影响：学习的核心在于复习
## 【okHttp】面试官：听说你熟悉OkHttp原理？
wanderingguy https://juejin.cn/post/6844904087788453896#heading-0
### 内容总结：
OkHttp基本实现原理
- 责任链模式
  - 实现各种拦截器，对网络请求链路进行处理
- 请求发起和返回的流程梳理

### 对自己的影响：学习OKHttp
## 【网络】https 协议是安全传输，为啥还要再加密？
hongyi0609 https://juejin.cn/post/7333162360360796171
### 内容总结：
 HTTPS为啥不能保证全链路安全？
- 端点安全性——中毒环境
- 中间人攻击，证书偷换
- 协议漏洞
OKHttp怎么提高网络请求的安全性？
- 对称加密 加密body
- 非对称加密 加密 对称加密的密钥
- 证书校验 保证非对称加密的密钥
- 创建SSLContext 兜底 证书校验的问题
### 对自己的影响：学习OKHttp如何提升Http的安全性
## 【四大组建】深入探索Android Service：后台服务的终极指南（上）
https://blog.csdn.net/lizhong2008/article/details/138133359 Service 基本启动方式，生命周期
https://blog.csdn.net/lizhong2008/article/details/138134982 Android 版本差异，保活能力 
https://blog.csdn.net/lizhong2008/article/details/138157450 Service性能优化
https://blog.csdn.net/lizhong2008/article/details/138165290 多线程开发、系统级操作
### 内容总结：
- Service 基本启动方式，生命周期
  - 启动服务
  - 绑定服务
- Android 版本差异，保活能力 
- Service 性能优化，使用技巧
- 多线程开发、系统级操作
  - Service在多线程环境下的最佳实践
  - Service 与系统级操作
  - Service 与系统资源管理
### 对自己的影响：全面复习Android Service
## 【Rxjava】响应式拿手好道-RxJava-RxAndroid实战指南
https://blog.csdn.net/lizhong2008/article/details/139075887
### 内容总结：
深入理解RxJava的核心概念和使用方式，并在Android平台下合理运用RxAndroid，掌握响应式编程的精髓。
- 基本概念
- 应用场景
  - 网络请求 与 数据合并Observable.zip
  - 梳理同步流程中的各种情况 DisposableObserver
  - 扩展实现Bus功能：RxBus、RxRelay，处理业务事件
- Android 中的应用
  - 主线程调度 AndroidSchedulers
  - 生命周期感知：RxLifecycle
  - View事件绑定：RxBinding
- 注意事项
  - 内存泄漏
  - 异常兜底处理
  - 背压问题：生产者 生产 > 消费者 消费
### 对自己的影响：学习RxJava

## 【思考】技术人修炼之道阅读笔记（六）解决对抗性思维方法
https://blog.csdn.net/lizhong2008/article/details/121767265
### 内容总结：
解决对抗性思维的有效方法是：“六顶思考帽”。
- 白色：中立客观，有理有据
- 绿色：创新思维
- 黄色：正向思考
- 黑色：批判性思维
- 红色：感性（直觉）思维
- 蓝色：领导者思维
### 对自己的影响：更好的思考
## 【软件设计】设计模式概念和七大原则
https://vlts.cn/post/design-pattern-basic-law
### 内容总结：面向对象的设计模式有七大基本原则：

- 开闭原则（Open Closed Principle，OCP）
- 单一职责原则（Single Responsibility Principle, SRP）
- 里氏代换原则（Liskov Substitution Principle，LSP）
- 依赖倒转原则（Dependency Inversion Principle，DIP）
- 接口隔离原则（Interface Segregation Principle，ISP）
- 合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）
- 最少知识原则（Least Knowledge Principle，LKP）或者迪米特法则（Law of Demeter，LOD）

- OCP        开闭原则        对扩展开放，对修改关闭
- SRP        单一职责原则        一个类只负责一个功能领域中的相应职责
- LSP        里氏代换原则        所有引用基类的地方必须能透明地使用其子类的对象
- DIP        依赖倒转原则        依赖于抽象，不能依赖于具体实现
- ISP        接口隔离原则        类之间的依赖关系应该建立在最小的接口上
- CARP        合成/聚合复用原则        尽量使用合成/聚合，而不是通过继承达到复用的目的
- LOD        迪米特法则        一个软件实体应当尽可能少的与其他实体发生相互作用
### 对自己的影响：温故而知新
设计模式总结
https://www.iocoder.cn/DesignPattern/xiaomingge/summary/
## 【线程池】深度解读 java 线程池设计思想及源码实现
https://javadoop.com/post/java-thread-pool#toc_0
### 内容总结：
- 类图结构，刚刚模块的作用
- 不同的功能线程池是如何初始化的
- 问题和解答：
  1. java 线程池有哪些关键属性？
    1. corePoolSize，maximumPoolSize，workQueue，keepAliveTime，rejectedExecutionHandler
    2. corePoolSize 到 maximumPoolSize 之间的线程会被回收，当然 corePoolSize 的线程也可以通过设置而得到回收（allowCoreThreadTimeOut(true)）。
    3. workQueue 用于存放任务，添加任务的时候，如果当前线程数超过了 corePoolSize，那么往该队列中插入任务，线程池中的线程会负责到队列中拉取任务。
    4. keepAliveTime 用于设置空闲时间，如果线程数超出了 corePoolSize，并且有些线程的空闲时间超过了这个值，会执行关闭这些线程的操作
    5. rejectedExecutionHandler 用于处理当线程池不能执行此任务时的情况，默认有抛出 RejectedExecutionException 异常、忽略任务、使用提交任务的线程来执行此任务和将队列中等待最久的任务删除，然后提交此任务这四种策略，默认为抛出异常。
  2. 说说线程池中的线程创建时机？临时线程，会在任务队列满了的时候，才会创建并执行。
    1. 如果当前线程数少于 corePoolSize，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务；
    2. 如果当前线程数已经达到 corePoolSize，那么将提交的任务添加到队列中，等待线程池中的线程去队列中取任务；
    3. 如果队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 maximumPoolSize，如果此时线程数超过了 maximumPoolSize，那么执行拒绝策略。
注意：如果将队列设置为无界队列，那么线程数达到 corePoolSize 后，其实线程数就不会再增长了。因为后面的任务直接往队列塞就行了，此时 maximumPoolSize 参数就没有什么意义。
### 对自己的影响：温故而知新

## 【微信小程序】weex框架使用
https://blog.csdn.net/ZT_KEBEI/article/details/123113923
https://weexapp.com/zh/guide/introduction.html#%E6%A6%82%E8%BF%B0
### 内容总结：
### 对自己的影响：温故而知新

## 【独立开发】独立开发者如何赚钱？（原理和思维）
https://mp.weixin.qq.com/s/8_g73xwsihgFQYn67BTP3Q
### 内容总结：独立开发赚钱思维
### 对自己的影响：学习 提升认知
