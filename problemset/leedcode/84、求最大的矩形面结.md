给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。
![tu](../../images/84-histogram-1.png)  
以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。  

![tu](../../images/84-histogram_area.png)   

图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。

## 思路
- 从暴力入手，不断优化
    - 分析一下，如何找到所有的情况
```java
public class Solution {
   public int largestRectangleArea(int[] heights) {
       int maxarea = 0;
       for (int i = 0; i < heights.length; i++) {
           for (int j = i; j < heights.length; j++) {
               int minheight = Integer.MAX_VALUE;
               for (int k = i; k <= j; k++)
                   minheight = Math.min(minheight, heights[k]);
               maxarea = Math.max(maxarea, minheight * (j - i + 1));
           }
       }
       return maxarea;
   }
}
// 优化
public class Solution {
   public int largestRectangleArea(int[] heights) {
       int maxarea = 0;
       for (int i = 0; i < heights.length; i++) {
           int minheight = Integer.MAX_VALUE;// 记录从 i开始的最矮的矩形
           for (int j = i; j < heights.length; j++) {
               minheight = Math.min(minheight, heights[j]);
               maxarea = Math.max(maxarea, minheight * (j - i + 1));
           }
       }
       return maxarea;
   }
}

// 作者：LeetCode
// 链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode/
// 来源：力扣（LeetCode）
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
- 递归分治思想
    - 按照最矮的珠子进行二分
```java
public class Solution {
   public int largestRectangleArea(int[] heights) {
       return calculateArea(heights,0,heights.length - 1);
   }
    
    private int calculateArea(int[] heights,int start,int end){
        // 递归结束判断
        if (start > end) return 0;
        int minIndex = start;
        for (int i = start;i <= end;i++){//耗时
            if (heights[minIndex] > heights[i]){
                minIndex = i;
            }
        }
        // 二分递归
        return Math.max(heights[minIndex]*(end - start + 1),Math.max(calculateArea(heights,start,minIndex - 1),calculateArea(heights,minIndex + 1,end)));
    }
}

// 作者：LeetCode
// 链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode/
// 来源：力扣（LeetCode）
```
- 利用线段树，查找最矮的柱子

- 利用栈的特点，
```java
public class Solution {
   public int largestRectangleArea(int[] heights) {
       Stack<Integer> stack = new Stack<>();
       stack.push(-1);
       int maxarea = 0;
       for (int i = 0;i < heights.length;i++) {
           while(stack.peek() != -1 && heights[stack.peek()] >= heights[i]) {
               maxarea = Math.max(maxarea,heights[stack.pop()]*(i - stack.peek() - 1));
           }
           stack.push(i);
       }
       while(stack.peek() != -1){
           maxarea = Math.max(maxarea,heights[stack.pop()]*(heights.length - stack.peek() - 1));
       }
       return maxarea;
   }
   
}

// 作者：LeetCode
// 链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode/
// 来源：力扣（LeetCode）
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 3min
```java
class Solution {
    
    
    public int largestRectangleArea(int[] heights) {
        int n=heights.length;
        if(n==0) return 0;
        int []leftMin=new int[n];
        int []rightMin=new int[n];
        leftMin[0]=-1;
        rightMin[n-1]=n;
        int res=0;
        for(int i=1;i<n;i++) 
        {
            int tmp=i-1;
            while(tmp >= 0 && heights[tmp] >= heights[i])// 找第一个递增的位置
            {
                tmp = leftMin[tmp];
            }
            leftMin[i]=tmp;// heights[i]的左侧扩展极限为tmp
        }
        for(int i=n-2;i>=0;i--)
        {
            int tmp=i+1;
            while(tmp<n && heights[tmp]>=heights[i])
            {
                tmp=rightMin[tmp];
            }
            rightMin[i]=tmp;// heights[i]的右侧扩展极限为tmp
        }
        for(int i=0;i<n;i++)
        {
            res=Math.max(res,(rightMin[i]-leftMin[i]-1)*heights[i]);
        }
        return res;
    }
}
```
- 1ms
```java
class Solution {
    public int largestRectangleArea(int[] heights) {        
        return helper(heights, 0, heights.length - 1);
    }
    
    private int helper(int[] heights, int start, int end){
        if(start > end){
            return 0;
        }
        if(start == end){
            return heights[start];
        }
        int min = heights[start];
        boolean sorted = true;
        for(int i = start + 1; i <= end; i++){// 求当前区间的最小值。 判断是否是非递减的
            min = Math.min(min, heights[i]);
            if(heights[i - 1] > heights[i]){
                sorted = false;
            }
        }
        if(sorted){// 排好序的直接遍历一遍求最大值
            int max = 0;
            for(int i = start; i <= end; i++){
                max = Math.max(max, heights[i] * (end - i + 1));
            }
            return max;
        }
        int area = min * (end - start + 1);
        int startIndex = start;
        for(int i = start; i <= end; i++){
            if(heights[i] == min){// 当前位置是最小值
                area = Math.max(area, helper(heights, startIndex, i - 1));// 递归
                startIndex = i + 1;
            }
        }
        return Math.max(area, helper(heights, startIndex, end));// 递归
    }
}
``