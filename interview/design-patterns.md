
# 设计模式

## 1、学习站点 
- [java设计模式](https://java-design-patterns.com/patterns/)
- [设计模式](https://cyc2018.xyz/%E5%85%B6%E5%AE%83/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.html#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80)
- [设计模式](https://refactoringguru.cn/design-patterns)

## 2、设计模式概述

设计模式指的是我们按照固定范式来构建项目代码，使得项目模块达到单一职责原则、高内聚低耦合、开闭原则、里氏替换原则等的软件设计目的。一般设计模式包括：创建型、结构型、行为型、复合型四个类型的设计模式。

创建型设计模式是以更好的创建和复用内存对象/实例为目的，从而发展出来的对象创建的固定范式，可以提升代码的灵活性和可复用性。常见的创建型模式有：
- 工厂方法（factory method）模式
- 抽象工厂（abstract factory）模式
- 生成器（builder / 构建者）模式
- 原型（prototype）模式
- 单例（singleton）模式

结构型模式是以更好的组合对象和类形成一个结构化的模块，从而更好的保持结构的灵活性和可扩展性。常见的结构性设计模式有：
- 适配器（adapter）模式
- 桥接（bridge）模式
- 组合（composite）模式
- 装饰（decorator）模式
- 外观（facade）模式
- 享元（flyweight）模式
- 代理（proxy）模式

行为型模式是以更好的组织模块功能代码为目的，从而对象之间可以高效沟通，对象的职责也内聚。常见的行为型设计模式有：
- 责任链（chain of responsebility）模式
- 命令（command）模式
- 迭代器（iterator）模式
- 中介者（mediator）模式
- 备忘录（memento）模式
- 观察者（observer）模式
- 状态（state）模式
- 策略（strategy）模式
- 模版方法（template method）模式
- 访问者（vistor）模式

## 3、创建型设计模式

### 3.1 工厂方法模式

父类定义子类创建的方法，子类实现具体的创建子类型。生产对象的工厂，只负责对生产流程设计，具体生产什么产品，依赖于工厂的类型。

- 使用场景：适用于产品类型较少的对象创建
- 优点：解耦、单一职责原则、开笔原则
- 缺点：子类膨胀，模块过于扁平


### 3.2 抽象工厂模式

引入工厂接口定义创建的产品方法，工厂实现类负责创建不同的产品，产品也进行抽象，用于代码复用。外部适用方需要一个持有一个工厂实现类对象，来创建自己需要的产品。

- 使用场景：适用于复杂产品类型结构的对象创建
- 优点：可扩展性强、低耦合、单一职责原则、开闭原则
- 缺点：代码结构复杂，不易理解

### 3.3 生成器（构建者）模式

生成器借口定义不同的方法来支持创建具备不同特性的对象，通过生成器子类不同方法配置不同的特性后返回生成器对象，实现持续不断的给对象装配不同的内容。

- 使用场景：中低层模块的初始化或者工具sdk（下载sdk、网络sdk等）的初始化配置
- 优点：代码复用、单一职责原则、代码结构清晰
- 缺点：生成器子类过多结构会冗余

### 3.4 原型模式

原型借口定义克隆方法，用于返回新的对象。一级实现类和二级实现类，都可以按照需求克隆新对象。

- 使用场景：对象的复制行为和具体对象代码解耦
- 优点：对象组合、适用于一定复杂度的对象创建、克隆解耦
- 缺点：不适用于循环引用的复杂场景

### 3.5 单例模式

只会创建一个实例，实例被封装到内部，通过get方法来获取。

- 使用场景：资源单一的业务，保证数据的唯一性
- 优点：只需初始化一次、全局访问收敛
- 缺点：多线程问题、单元测试困难、封装简单

## 4、 结构型模式

### 4.1 适配器模式

通过适配类实现接口，组合不同业务之对象，使得系统获得一定的兼容性。

- 使用场景：扩展一些模块已达到具备新特性的目的
- 优点：开闭原则、单一职责原则
- 缺点：结构复杂度增加

### 4.2 桥接模式

通过桥接类使用接口的方法，桥接多种实现累，从而实现不同的场景功能。

- 使用场景：需要一定的特权去使用模块功能
- 优点：开闭原则、单一职责原则
- 缺点：破坏内聚性

### 4.3 组合模式

组合同一类型的对象，构成树形结构，实现复杂的功能

- 示例：图形编辑器
- 使用场景：组合一系列对象实现一些功能
- 优点：开闭原则、
- 缺点：难以处理不同类型的对象、抽象过度难以理解


### 4.4 装饰模式

将对象交给特殊逻辑的业务使用，以扩展功能。

- 示例：数据加密和压缩功能
- 使用场景：引用新的对象，来实现特殊功能。
- 优点：横向扩展、单一职责、不破坏原本的接口定义
- 缺点：过多封装

### 4.5 外观模式
- 示例：客户端和复杂视频转换框架的交互逻辑
- 使用场景：
- 优点：
- 缺点：


### 4.6 享元模式
- 示例：画布渲染百万级别对象内存优化
- 使用场景：对大规模单一类型对象的复用
- 优点：
- 缺点：

### 4.7 代理模式

- 示例：众多视频功能代理，实现功能统一化
- 使用场景：代理原有对象功能，额外实现新功能
- 优点：
- 缺点：


## 5、 行为型模式

### 5.1 责任链模式

- 示例：
- 使用场景：
- 优点：
- 缺点：

### 5.2 命令模式

- 示例：
- 使用场景：
- 优点：
- 缺点：

### 5.3 迭代器模式

- 示例：
- 使用场景：
- 优点：
- 缺点：

### 5.4 中介者模式

- 示例：
- 使用场景：
- 优点：
- 缺点：

### 5.5 备忘录模式

- 示例：
- 使用场景：
- 优点：
- 缺点：

### 5.6 观察者模式

- 示例：
- 使用场景：
- 优点：
- 缺点：

### 5.7 状态模式

- 示例：
- 使用场景：
- 优点：
- 缺点：

### 5.8 策略模式

- 示例：
- 使用场景：
- 优点：
- 缺点：


### 5.9 模版方法模式

- 示例：
- 使用场景：
- 优点：
- 缺点：

### 5.10 访问者模式

- 示例：
- 使用场景：
- 优点：
- 缺点：


## 6、项目实际应用

### 6.1 设计模式在jdk中的应用

### 6.3 设计模式在SpringMVC框架中的应用

### 6.2 设计模式在Android系统中的应用

### 6.4 设计模式在Android 开源组件中的应用

