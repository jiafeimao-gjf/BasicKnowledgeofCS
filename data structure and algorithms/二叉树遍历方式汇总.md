## C++实现
```C++
#include <iostream>
#include <queue>

using namespace std;

struct Node{
	int val;
	Node *l,*r,*p;
	Node(int val) : val(val),l(NULL),r(NULL),p(NULL) {}
}; 

bool search(Node *root,int _val){
	if(root == NULL){
		return false;
	}else if(root->val == _val) { 
		return true;
	}else if(_val < root->val) return search(root->l,_val);
	else return search(root->r,_val);
}

bool insert(Node *root,int _val){
	
}

bool preolder(Node *root){
	if(root){
		cout<<root->val<<' ';
		if(preolder(root->l)) {
			if(preolder(root->r)) return true;
		}
	}else return true;
}

bool inolder(Node *root){
	if(root){
		if(inolder(root->l)) {
			cout<<root->val<<' ';
			if(inolder(root->r)) return true;
		}
	}else return true;
}

bool postolder(Node *root){
	if(root){
		if(postolder(root->l)) {
			if(postolder(root->r)) {
				cout<<root->val<<' ';
				return true;
			}
		}
	}else return true;
}

int main(){
	int value;
	Node *rrt = NULL,*rt = NULL;
	cout<<"请输入一行待排序的数组，负数表示退出输入:"<<endl;
	while(cin>>value && (value > 0)){
		if(insert(rt,value)){
			cout<<"成功插入到二叉排序树"<<endl;
		}else{
			cout<<"该节点已存在！"<<endl;
		} 
		cout<<"中序遍历输出："<<endl; 
		inolder(rt);	cout<<endl;
	}
	/**
	if(rt != NULL){
		cout<<"前序遍历输出："<<endl; 
		preolder(rt); 	cout<<endl;
		cout<<"中序遍历输出："<<endl; 
		inolder(rt);	cout<<endl;
		cout<<"后序遍历输出："<<endl; 
		postolder(rt);	cout<<endl;
	}*/

	return 0;
}

```

#### 二叉树重建
```C++
// 根据后序和中序递归确定树
#include <cstdio>
#include <queue>
struct Node
{
	int l, r;
	Node() { l = r = -1; }
};
Node t[32]; // tree
int pre[32];
int in[32];

int pin_build(int pl, int pr, int il, int ir)
{
	if (pl > pr)
	{ //根找完了
		return -1;
	}
	int p = il;
	while (pre[pl] != in[p])
		p++; //找到一个根的位置
	int tree = pre[pl];
	t[tree].l = build(pl + 1, pl - il + p, il, p - 1); //左子树递归找根
	t[tree].r = build(pl - il + p + 1, pr, p + 1, ir); //右子树递归找根
	return tree;
}
int inp_build(int pl, int pr, int il, int ir)
{
	if (pl > pr)
	{
		return -1;
	}
	int p = il;
	while (pre[pr] != in[p])
		p++;
	int tree = pre[pr];
	t[tree].l = build(pl, pr - ir + p - 1, il, p - 1);
	t[tree].r = build(pr - ir + p, pr - 1, p + 1, ir);
	return tree;
}
bool pre(int root)
{
	if (root != -1)
	{
		cout << root << ' ';
		if (pre(t[root].l))
		{
			if (pre(t[root].r))
			{
				return true;
			}
		}
	}
	else
		return true;
}

bool in(int root)
{
	if (root != -1)
	{
		if (in(t[root].l))
		{
			cout << root << ' ';
			if (in(t[root].r))
			{
				return true;
			}
		}
	}
	else
		return true;
}

bool post(int root)
{
	if (root != -1)
	{
		if (post(t[root].l))
		{
			if (post(t[root].r))
			{
				cout << root << ' ';
				return true;
			}
		}
	}
	else
		return true;
}

void level(int root)
{
	std::queue<int> q;
	q.push(root);
	while (!q.empty())
	{
		int p = q.front();
		printf("%d", p);
		if (t[p].l != -1)
			q.push(t[p].l);
		if (t[p].r != -1)
			q.push(t[p].r);
		q.pop();
		if (q.size() != 0)
			printf(" ");
	}
}

int main()
{
	int n;
	scanf("%d", &n);
	for (int i = 0; i < n; ++i)
	{
		scanf("%d", &pre[i]);
	}
	for (int i = 0; i < n; ++i)
	{
		scanf("%d", &in[i]);
	}
	pin_build(0, n - 1, 0, n - 1);
	int root = pre[0];
	level(root);
	return 0;
}

```